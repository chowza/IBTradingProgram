/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package IBconnect;

import com.ib.client.Contract;
import com.ib.client.EClientSocket;
import java.awt.Color;
import java.awt.FlowLayout;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JTextField;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.quartz.CronTrigger;
import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.impl.StdSchedulerFactory;
import static org.quartz.JobBuilder.*;
import org.quartz.SchedulerFactory;
import static org.quartz.TriggerBuilder.*;
import static org.quartz.SimpleScheduleBuilder.*;
import static org.quartz.CronScheduleBuilder.*;
import org.quartz.JobDataMap;
import org.quartz.Trigger;
/**
 *
 * @author Terence
 */
public class IBTradeGui extends javax.swing.JFrame {
    
    //declare scheduler and factory variables
    static SchedulerFactory sf;
    static Scheduler sched;
              
    //declare IB wrapper and eclientsocket variable
    static someWrapper wrapper;
    static EClientSocket connection;
    static String host;
    static int port;
    static int clientId;
    
    //declare other variables
    private static HashMap<Integer,Integer> volumes;
    private static HashMap<Integer,Contract> contractList;
    protected static List<String> tradingSymbols;
    private static HashMap<Integer,String> keySymbols;
    public static HashMap<Integer,Contract>contractListDownloadedToPSQL;
    public static DateTimeFormatter formatterForHistoricalData;
    DateTimeFormatter formatterForParsing;
    DateTimeFormatter formatterForInserting;
    static DateTime dt;
    String url;
    Connection con;
    Statement st;
    public static HashMap <String,Contract> mostActiveContractList;
    double hd_open;
    double hd_high;
    double hd_low;
    double hd_close;
    double hd_barsize;
    int hd_volume;
    DateTime hd_date;
    public HashMap <Integer,Contract> reqIDtoContract;//when requesting real time data for contracts, put reqID and Contract in
    public static int idsForReqs;
    /**
     * Creates new form IBTradeGui
     */
    public IBTradeGui() {
        
        wrapper = new someWrapper();
        connection =  new EClientSocket(wrapper);
        initComponents();
        volumes = new HashMap();
        contractList = new HashMap();
        keySymbols = new HashMap();
        mostActiveContractList = new HashMap();
        contractListDownloadedToPSQL = new HashMap();
        reqIDtoContract = new HashMap();
        tradingSymbols = new ArrayList<>();
        formatterForHistoricalData = DateTimeFormat.forPattern("yyyyMMdd HH:mm:ss");
        formatterForParsing = DateTimeFormat.forPattern("yyyyMMdd  HH:mm:ss");
        formatterForInserting = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");
        dt = new DateTime();
        url = "jdbc:postgresql://localhost/IBDB";
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        textTradeList = new javax.swing.JTextArea();
        textSessionProfit = new javax.swing.JTextField();
        labelSessionProfit = new javax.swing.JLabel();
        textConnectionStatus = new javax.swing.JTextField();
        labelConnectionStatus = new javax.swing.JLabel();
        tradeButton = new javax.swing.JButton();
        checkBoxesPanel = new javax.swing.JPanel();
        checkboxPA = new javax.swing.JCheckBox();
        checkboxES = new javax.swing.JCheckBox();
        checkboxZL = new javax.swing.JCheckBox();
        checkboxHG = new javax.swing.JCheckBox();
        checkboxHO = new javax.swing.JCheckBox();
        checkboxLE = new javax.swing.JCheckBox();
        checkboxZW = new javax.swing.JCheckBox();
        checkboxZC = new javax.swing.JCheckBox();
        checkboxNG = new javax.swing.JCheckBox();
        checkboxPL = new javax.swing.JCheckBox();
        checkboxGC = new javax.swing.JCheckBox();
        checkboxZB = new javax.swing.JCheckBox();
        checkboxSI = new javax.swing.JCheckBox();
        checkboxZN = new javax.swing.JCheckBox();
        checkboxHE = new javax.swing.JCheckBox();
        checkboxZO = new javax.swing.JCheckBox();
        checkboxGF = new javax.swing.JCheckBox();
        checkboxCL = new javax.swing.JCheckBox();
        checkboxSelectAll = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("IB Trading Program");
        setMinimumSize(new java.awt.Dimension(442, 360));

        textTradeList.setEditable(false);
        textTradeList.setColumns(20);
        textTradeList.setLineWrap(true);
        textTradeList.setRows(5);
        jScrollPane1.setViewportView(textTradeList);

        textSessionProfit.setEditable(false);
        textSessionProfit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textSessionProfitActionPerformed(evt);
            }
        });

        labelSessionProfit.setText("Session Profit");
        labelSessionProfit.setMinimumSize(new java.awt.Dimension(0, 14));

        textConnectionStatus.setEditable(false);

        labelConnectionStatus.setText("Connection Status");
        labelConnectionStatus.setMinimumSize(new java.awt.Dimension(0, 14));

        tradeButton.setText("Start Trading");
        tradeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                tradeButtonActionPerformed(evt);
            }
        });

        checkBoxesPanel.setMinimumSize(new java.awt.Dimension(369, 56));
        checkBoxesPanel.setName(""); // NOI18N
        checkBoxesPanel.setPreferredSize(new java.awt.Dimension(369, 56));
        checkBoxesPanel.setLayout(new FlowLayout(FlowLayout.LEADING));

        checkboxPA.setText("PA");
        checkboxPA.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxPA.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxPA.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxPA.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxPAActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxPA);

        checkboxES.setText("ES");
        checkboxES.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxES.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxES.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxES.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxESActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxES);

        checkboxZL.setText("ZL");
        checkboxZL.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxZL.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxZL.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxZL.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxZLActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxZL);

        checkboxHG.setText("HG");
        checkboxHG.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxHG.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxHG.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxHG.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxHGActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxHG);

        checkboxHO.setText("HO");
        checkboxHO.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxHOActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxHO);

        checkboxLE.setText("LE");
        checkboxLE.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxLE.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxLE.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxLE.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxLEActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxLE);

        checkboxZW.setText("ZW");
        checkboxZW.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxZWActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxZW);

        checkboxZC.setText("ZC");
        checkboxZC.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxZC.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxZC.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxZC.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxZCActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxZC);

        checkboxNG.setText("NG");
        checkboxNG.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxNG.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxNG.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxNG.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxNGActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxNG);

        checkboxPL.setText("PL");
        checkboxPL.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxPL.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxPL.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxPL.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxPLActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxPL);

        checkboxGC.setText("GC");
        checkboxGC.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxGC.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxGC.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxGC.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxGCActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxGC);

        checkboxZB.setText("ZB");
        checkboxZB.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxZB.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxZB.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxZB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxZBActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxZB);

        checkboxSI.setText("SI");
        checkboxSI.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxSI.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxSI.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxSI.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxSIActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxSI);

        checkboxZN.setText("ZN");
        checkboxZN.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxZN.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxZN.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxZN.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxZNActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxZN);

        checkboxHE.setText("HE");
        checkboxHE.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxHE.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxHE.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxHE.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxHEActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxHE);

        checkboxZO.setText("ZO");
        checkboxZO.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxZO.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxZO.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxZO.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxZOActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxZO);

        checkboxGF.setText("GF");
        checkboxGF.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxGF.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxGF.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxGF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxGFActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxGF);

        checkboxCL.setText("CL");
        checkboxCL.setMaximumSize(new java.awt.Dimension(41, 23));
        checkboxCL.setMinimumSize(new java.awt.Dimension(41, 23));
        checkboxCL.setPreferredSize(new java.awt.Dimension(41, 23));
        checkboxCL.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxCLActionPerformed(evt);
            }
        });
        checkBoxesPanel.add(checkboxCL);

        checkboxSelectAll.setText("Select All ");
        checkboxSelectAll.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        checkboxSelectAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkboxSelectAllActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(checkBoxesPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 447, Short.MAX_VALUE)
                    .addComponent(checkboxSelectAll, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(tradeButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(labelConnectionStatus, javax.swing.GroupLayout.PREFERRED_SIZE, 106, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(textConnectionStatus)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(labelSessionProfit, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(textSessionProfit, javax.swing.GroupLayout.PREFERRED_SIZE, 68, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 237, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(textSessionProfit, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(labelSessionProfit, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(textConnectionStatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(labelConnectionStatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addComponent(checkBoxesPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkboxSelectAll, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(tradeButton)
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {labelConnectionStatus, labelSessionProfit, textConnectionStatus, textSessionProfit});

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void textSessionProfitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textSessionProfitActionPerformed
       // TODO add your handling code here:
    }//GEN-LAST:event_textSessionProfitActionPerformed

    private void tradeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_tradeButtonActionPerformed
        
        setTradeListText("Trading Started");
         //start account updates so we can check what position our contracts are
         connection.reqAccountUpdates(true,"DU94676");
         
         // schedule historical data requests for the next 30 minutes such that we check
         // the 9 contracts of each symbol and determine which is the most active
         // then sleep for 40 minutes and download the past years worth of data on these contracts
        try {
            
         JobDetail choosejob = newJob(chooseMostActiveContract.class)
                                .withIdentity("choostContractsJob","chooseContracts")
                                .build();
         
         Trigger choosetrigger = newTrigger()
                  .withIdentity("chooseContractsTrigger", "chooseContracts")
                  .startNow()
                  .build();
            sched.scheduleJob(choosejob,choosetrigger);
            Logger.getLogger(IBTradeGui.class.getName()).info("Choose contracts just scheduled, sleeping 40 minutes");
            Thread.sleep(600000*4);
            Logger.getLogger(IBTradeGui.class.getName()).info("Done sleeping 40 minutes");
        } catch (SchedulerException | InterruptedException ex) {
            Logger.getLogger(IBTradeGui.class.getName()).log(Level.SEVERE, null, ex);
        }
                 
         Logger.getLogger(IBTradeGui.class.getName()).info("Downloading past years data to PSQL");
        //here we iterate over the selected symbols to download historical data on the mostActiveContracts and put it in the PSQL db
               for (int i = 0; i < tradingSymbols.size(); i++){
                    idsForReqs+=1;
                    contractListDownloadedToPSQL.put(idsForReqs,mostActiveContractList.get(tradingSymbols.get(i)));
                    downloadData(idsForReqs,mostActiveContractList.get(tradingSymbols.get(i)),dt.toString(formatterForHistoricalData),
                       "1 Y","1 day","TRADES",0,1); //second to last option, 0 = outside regular trading hours 1 = rth
                }
        // If we have a position on a contract that is not the most active contract, we want to close out that position
        // and open up the same position on a more active contract. The below schedules that action
        try {
            Logger.getLogger(IBTradeGui.class.getName()).info("Now Scheduling closeOldOpenMoreActive...");
            JobDetail job = newJob(closeOldOpenMoreActive.class)
                                .usingJobData("m_symbol",tradingSymbols.get(0))
                                .usingJobData("m_expiry",mostActiveContractList.get(tradingSymbols.get(0)).m_expiry)
                                .withIdentity("closeOldOpenMoreActiveJob","UseMostActiveContracts")
                                .build();
            
            CronTrigger trigger = newTrigger()
                  .withIdentity("updateDataTrigger0", "useMostActiveContracts")
                  .withSchedule(cronSchedule("0 40 12 ? 1-12 2-6")) 
                  .build();
            sched.scheduleJob(job,trigger);
            
            for (int i = 1; i < tradingSymbols.size(); i++){
                    job = newJob(closeOldOpenMoreActive.class)
                                        .usingJobData("m_symbol",tradingSymbols.get(i))
                                        .usingJobData("m_expiry",mostActiveContractList.get(tradingSymbols.get(i)).m_expiry)
                                        .withIdentity("closeOldOpenMoreActiveJob" + Integer.toString(i),"UseMostActiveContracts")
                                        .build();

                    trigger = newTrigger()
                          .withIdentity("updateDataTrigger" + Integer.toString(i), "useMostActiveContracts")
                          .withSchedule(cronSchedule(Integer.toString(i*3)+" 50 12 ? 1-12 2-6")) 
                          .build();
                    sched.scheduleJob(job,trigger);
            }
        }catch (SchedulerException ex) {
            Logger.getLogger(IBTradeGui.class.getName()).log(Level.SEVERE, null, ex);
        }    
               
               
        // schedule updating PSQL db and placing orders
        try {      
            Logger.getLogger(IBTradeGui.class.getName()).info("Now Scheduling updating of PSQL and placing orders...");
            
            JobDetail job = newJob(updatePSQL.class)
                                .usingJobData("m_symbol",tradingSymbols.get(0))
                                .usingJobData("m_expiry",mostActiveContractList.get(tradingSymbols.get(0)).m_expiry)
                                .withIdentity("updateDataJob0","updatePSQLs")
                                .build();
            
              //set the update and the closing hours. Note that update must happen before placing the order
              String updateHours = "";
              String closingHours = ""; 
              int closingSeconds;
              closingSeconds = 0;
              String closingSched;
              
              switch(tradingSymbols.get(0)){
                    case "ZC": case "ZW": case "ZO": case "ZL":
                        // second,minute,hour,day of month,month,day of week,year (note that seconds has been taken off here to be added later
                        updateHours = " 0 15 ? 1-12 2-6"; 
                        closingHours = " 10 15 ? 1-12 2-6";
                        break;
                    case "ES":
                        updateHours = " 25 16 ? 1-12 2-6";
                        closingHours = " 29 16 ? 1-12 2-6";
                        break;
                    case "LE": case "GF": case "HE": case "ZN": case "ZB":
                        updateHours = " 30 17 ? 1-12 2-6";
                        closingHours = " 50 17 ? 1-12 2-6";
                        break;
                    case "HG": case "GC": case "SI": case "PA": case "PL": case "CL":
                    case "HO": case "NG": 
                        updateHours = " 45 17 ? 1-12 2-6";
                        closingHours = " 55 17 ? 1-12 2-6";
                        break;
                }
              
              //add seconds to the cron schedule so that orders don't fire simultaneously and as a result
              // fire with the same reqID (i.e avoid duplicate order id)
              String updateSched = closingSeconds + updateHours;
              closingSched = closingSeconds + closingHours;

              CronTrigger trigger = newTrigger()
                  .withIdentity("updateDataTrigger0", "updatePSQLs")
                  .withSchedule(cronSchedule(updateSched)) 
                  .build();
                sched.scheduleJob(job,trigger);
            
            // placing order on first symbol selected
                          
                
            job = newJob(placeOrderScheduler.class)
                                .usingJobData("m_symbol",tradingSymbols.get(0))
                                .usingJobData("m_expiry",mostActiveContractList.get(tradingSymbols.get(0)).m_expiry)
                                .withIdentity("orderJob0","placeOrders")
                                .build();
              
              trigger = newTrigger()
                  .withIdentity("orderTrigger0", "placeOrders")
                      // second,minute,hour,day of month,month,day of week,year
                  .withSchedule(cronSchedule(closingSched)) // scheduling well after closing time but before opening times"
                  .build();
            sched.scheduleJob(job,trigger);
            
            for (int i = 1; i < tradingSymbols.size(); i++){
                // set update and place order schedules based on when the break period is
                  switch(tradingSymbols.get(i)){
                    case "ZC": case "ZW": case "ZO": case "ZL":
                        updateHours = " 0 15 ? 1-12 2-6";
                        closingHours = " 10 15 ? 1-12 2-6";
                        break;
                    case "ES":
                        updateHours = " 25 16 ? 1-12 2-6";
                        closingHours = " 29 16 ? 1-12 2-6";
                        break;
                    case "LE": case "GF": case "HE": case "ZN": case "ZB":
                        updateHours = " 30 17 ? 1-12 2-6";
                        closingHours = " 50 17 ? 1-12 2-6";
                        break;
                    case "HG": case "GC": case "SI": case "PA": case "PL": case "CL":
                    case "HO": case "NG": 
                        updateHours = " 45 17 ? 1-12 2-6";
                        closingHours = " 55 17 ? 1-12 2-6";
                        break;
                }
                // add in seconds so that orders dont fire simultaneously with same reqId
                  closingSeconds = i*3;
                  closingSched = closingSeconds + closingHours;
                  updateSched = closingSeconds + updateHours;
                // schedule update
                job = newJob(updatePSQL.class)
                                .usingJobData("m_symbol",tradingSymbols.get(i))
                                .usingJobData("m_expiry",mostActiveContractList.get(tradingSymbols.get(i)).m_expiry)
                                .withIdentity("updateDataJob" + Integer.toString(i),"updatePSQLs")
                                .build();
              
                trigger = newTrigger()
                  .withIdentity("updateDataTrigger" + Integer.toString(i), "updatePSQLs")
                  .withSchedule(cronSchedule(updateSched)) // scheduling well after closing time but before opening times"
                  .build();
                sched.scheduleJob(job,trigger);
            
                //schedule placing order
                  job = newJob(placeOrderScheduler.class)
                                    .usingJobData("m_symbol",tradingSymbols.get(i))
                                    .usingJobData("m_expiry",mostActiveContractList.get(tradingSymbols.get(i)).m_expiry)
                                    .withIdentity("orderJob"+Integer.toString(i),"placeOrders")
                                    .build();
                
                  trigger = newTrigger()
                      .withIdentity("orderTrigger"+Integer.toString(i), "placeOrders")
                      .withSchedule(cronSchedule(closingSched)) // second,minute,hour,day of month,month,day of week,year
                      .build();
                  sched.scheduleJob(job,trigger);
            }
  
            
        } catch (SchedulerException ex) {
            Logger.getLogger(IBTradeGui.class.getName()).log(Level.SEVERE, null, ex);
        }  
         
    }//GEN-LAST:event_tradeButtonActionPerformed

    private void checkboxZCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxZCActionPerformed
        if(checkboxZC.isSelected()){
            if (!tradingSymbols.contains("ZC")){
                tradingSymbols.add("ZC");
                setTradeListText("Added ZC");
            }
        }
        else {
                tradingSymbols.remove("ZC");
                setTradeListText("Removed ZC");
        }
    }//GEN-LAST:event_checkboxZCActionPerformed

    private void checkboxPLActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxPLActionPerformed
         if(checkboxPL.isSelected()){
            if (!tradingSymbols.contains("PL")){
                tradingSymbols.add("PL");
                setTradeListText("Added PL");
            }
        }
        else {
                tradingSymbols.remove("PL");
                setTradeListText("Removed PL");
        }
    }//GEN-LAST:event_checkboxPLActionPerformed

    private void checkboxZWActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxZWActionPerformed
        if(checkboxZW.isSelected()){
            if (!tradingSymbols.contains("ZW")){
                tradingSymbols.add("ZW");
                setTradeListText("Added ZW");
            }
        }
        else {
                tradingSymbols.remove("ZW");
                setTradeListText("Removed ZW");
        }
    }//GEN-LAST:event_checkboxZWActionPerformed

    private void checkboxZOActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxZOActionPerformed
        if(checkboxZO.isSelected()){
            if (!tradingSymbols.contains("ZO")){
                tradingSymbols.add("ZO");
                setTradeListText("Added ZO");
            }
        }
        else {
                tradingSymbols.remove("ZO");
                setTradeListText("Removed ZO");
        }
    }//GEN-LAST:event_checkboxZOActionPerformed

    private void checkboxHGActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxHGActionPerformed
        if(checkboxHG.isSelected()){
            if (!tradingSymbols.contains("HG")){
                tradingSymbols.add("HG");
                setTradeListText("Added HG");
            }
        }
        else {
                tradingSymbols.remove("HG");
                setTradeListText("Removed HG");
        }
    }//GEN-LAST:event_checkboxHGActionPerformed

    private void checkboxSIActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxSIActionPerformed
        if(checkboxSI.isSelected()){
            if (!tradingSymbols.contains("SI")){
                tradingSymbols.add("SI");
                setTradeListText("Added SI");
            }
        }
        else {
                tradingSymbols.remove("SI");
                setTradeListText("Removed SI");
        }
    }//GEN-LAST:event_checkboxSIActionPerformed

    private void checkboxCLActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxCLActionPerformed
        if(checkboxCL.isSelected()){
            if (!tradingSymbols.contains("CL")){
                tradingSymbols.add("CL");
                setTradeListText("Added CL");
            }
        }
        else {
                tradingSymbols.remove("CL");
                setTradeListText("Removed CL");
        }
    }//GEN-LAST:event_checkboxCLActionPerformed

    private void checkboxHOActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxHOActionPerformed
        if(checkboxHO.isSelected()){
            if (!tradingSymbols.contains("HO")){
                tradingSymbols.add("HO");
                setTradeListText("Added HO");
            }
        }
        else {
                tradingSymbols.remove("HO");
                setTradeListText("Removed HO");
        }
    }//GEN-LAST:event_checkboxHOActionPerformed

    private void checkboxESActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxESActionPerformed
        if(checkboxES.isSelected()){
            if (!tradingSymbols.contains("ES")){
                tradingSymbols.add("ES");
                setTradeListText("Added ES");
            }
        }
        else {
                tradingSymbols.remove("ES");
                setTradeListText("Removed ES");
        }
    }//GEN-LAST:event_checkboxESActionPerformed

    private void checkboxZBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxZBActionPerformed
        if(checkboxZB.isSelected()){
            if (!tradingSymbols.contains("ZB")){
                tradingSymbols.add("ZB");
                setTradeListText("Added ZB");
            }
        }
        else {
                tradingSymbols.remove("ZB");
                setTradeListText("Removed ZB");
        }
    }//GEN-LAST:event_checkboxZBActionPerformed

    private void checkboxGFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxGFActionPerformed
        if(checkboxGF.isSelected()){
            if (!tradingSymbols.contains("GF")){
                tradingSymbols.add("GF");
                setTradeListText("Added GF");
            }
        }
        else {
                tradingSymbols.remove("GF");
                setTradeListText("Removed GF");
        }
    }//GEN-LAST:event_checkboxGFActionPerformed

    private void checkboxLEActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxLEActionPerformed
        if(checkboxLE.isSelected()){
            if (!tradingSymbols.contains("LE")){
                tradingSymbols.add("LE");
                setTradeListText("Added LE");
            }
        }
        else {
                tradingSymbols.remove("LE");
                setTradeListText("Removed LE");
        }
    }//GEN-LAST:event_checkboxLEActionPerformed

    private void checkboxZNActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxZNActionPerformed
        if(checkboxZN.isSelected()){
            if (!tradingSymbols.contains("ZN")){
                tradingSymbols.add("ZN");
                setTradeListText("Added ZN");
            }
        }
        else {
                tradingSymbols.remove("ZN");
                setTradeListText("Removed ZN");
        }
    }//GEN-LAST:event_checkboxZNActionPerformed

    private void checkboxHEActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxHEActionPerformed
        if(checkboxHE.isSelected()){
            if (!tradingSymbols.contains("HE")){
                tradingSymbols.add("HE");
                setTradeListText("Added HE");
            }
        }
        else {
                tradingSymbols.remove("HE");
                setTradeListText("Removed HE");
        }
    }//GEN-LAST:event_checkboxHEActionPerformed

    private void checkboxNGActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxNGActionPerformed
        if(checkboxNG.isSelected()){
            if (!tradingSymbols.contains("NG")){
                tradingSymbols.add("NG");
                setTradeListText("Added NG");
            }
        }
        else {
                tradingSymbols.remove("NG");
                setTradeListText("Removed NG");
        }
    }//GEN-LAST:event_checkboxNGActionPerformed

    private void checkboxZLActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxZLActionPerformed
        if(checkboxZL.isSelected()){
            if (!tradingSymbols.contains("ZL")){
                tradingSymbols.add("ZL");
                setTradeListText("Added ZL");
            }
        }
        else {
                tradingSymbols.remove("ZL");
                setTradeListText("Removed ZL");
        }
    }//GEN-LAST:event_checkboxZLActionPerformed

    private void checkboxPAActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxPAActionPerformed
        if(checkboxPA.isSelected()){
            if (!tradingSymbols.contains("PA")){
                tradingSymbols.add("PA");
                setTradeListText("Added PA");
            }
        }
        else {
                tradingSymbols.remove("PA");
                setTradeListText("Removed PA");
        }
    }//GEN-LAST:event_checkboxPAActionPerformed

    private void checkboxGCActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxGCActionPerformed
        if(checkboxGC.isSelected()){
            if (!tradingSymbols.contains("GC")){
                tradingSymbols.add("GC");
                setTradeListText("Added GC");
            }
        }
        else {
                tradingSymbols.remove("GC");
                setTradeListText("Removed GC");
        }
    }//GEN-LAST:event_checkboxGCActionPerformed

    private void checkboxSelectAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkboxSelectAllActionPerformed
        if (checkboxSelectAll.isSelected()){
            checkboxZC.doClick();
            checkboxZO.doClick();
            checkboxSI.doClick();
            checkboxCL.doClick();
            checkboxES.doClick();
            checkboxGF.doClick();
            checkboxZN.doClick();
            checkboxNG.doClick();
            checkboxPA.doClick();
            checkboxZW.doClick();
            checkboxHG.doClick();
            checkboxPL.doClick();
            checkboxHO.doClick();
            checkboxZB.doClick();
            checkboxLE.doClick();
            checkboxHE.doClick();
            checkboxZL.doClick();
            checkboxGC.doClick();
        }
        else {
            checkboxZC.doClick();
            checkboxZO.doClick();
            checkboxSI.doClick();
            checkboxCL.doClick();
            checkboxES.doClick();
            checkboxGF.doClick();
            checkboxZN.doClick();
            checkboxNG.doClick();
            checkboxPA.doClick();
            checkboxZW.doClick();
            checkboxHG.doClick();
            checkboxPL.doClick();
            checkboxHO.doClick();
            checkboxZB.doClick();
            checkboxLE.doClick();
            checkboxHE.doClick();
            checkboxZL.doClick();
            checkboxGC.doClick();
            
        }
    }//GEN-LAST:event_checkboxSelectAllActionPerformed
    
    
    public void setConnectionText(boolean status, IBTradeGui TradeInstance){
        if (status){
            TradeInstance.textConnectionStatus.setText("Connected!");
            TradeInstance.textConnectionStatus.setForeground(Color.green);
        } 
        else {
            TradeInstance.textConnectionStatus.setText("Waiting for Connection...");
            TradeInstance.textConnectionStatus.setForeground(Color.red);
        }
    }
    
    public void setTradeListText(String tradeslist){
        this.textTradeList.insert(tradeslist,0);
        this.textTradeList.insert("\n \n",0);
    }
    
    public void downloadData(int tickerId, Contract contract, String endDateTime, 
            String durationStr, String barSizeSetting, String whatToShow, int useRTH, int formatDate){
            

            try{
            con = DriverManager.getConnection(url, "developer", "password");
            st = con.createStatement();

            st.execute("CREATE TABLE IF NOT EXISTS " + contract.m_symbol + contract.m_expiry
                    + " ( _date date, "
                    + "open double precision, high double precision, low double precision, close double precision, "
                    + "volume integer, barsize double precision, PRIMARY KEY(_date))");
            }
            
            catch (Exception e){
                Logger.getLogger(IBTradeGui.class.getName()).log(java.util.logging.Level.SEVERE, null, e);
            } finally {
            try {
                if (st != null) {
                    st.close();
                }
                if (con != null) {
                    con.close();
                }

            } catch (SQLException ex) {
                //exception
            }
            }
            
            connection.reqHistoricalData(tickerId, contract, endDateTime, durationStr, 
              barSizeSetting, whatToShow, useRTH, formatDate);
    }
    
    public static void chooseContract(String symbol){
        //test the next 9 months for the contract with most volume and choose the contract with most volume
        if (!contractListDownloadedToPSQL.isEmpty()){
            contractListDownloadedToPSQL.clear();
        }
        
        //create 9 contracts, 1 for each month
        Contract contract1 = new Contract();
        Contract contract2 = new Contract();
        Contract contract3 = new Contract();
        Contract contract4 = new Contract();
        Contract contract5 = new Contract();
        Contract contract6 = new Contract();
        Contract contract7 = new Contract();
        Contract contract8 = new Contract();
        Contract contract9 = new Contract();
        
        //set expiry month of each contract
        DateTimeFormatter customFormatter = DateTimeFormat.forPattern("yyyyMM");
        DateTime result = dt.plusMonths(1);
        contract1.m_expiry = dt.toString(customFormatter);
        contract2.m_expiry = result.toString(customFormatter);
        result = result.plusMonths(1);
        contract3.m_expiry = result.toString(customFormatter);
        result = result.plusMonths(1);
        contract4.m_expiry = result.toString(customFormatter);
        result = result.plusMonths(1);
        contract5.m_expiry = result.toString(customFormatter);
        result = result.plusMonths(1);
        contract6.m_expiry = result.toString(customFormatter);
        result = result.plusMonths(1);
        contract7.m_expiry = result.toString(customFormatter);
        result = result.plusMonths(1);
        contract8.m_expiry = result.toString(customFormatter);
        result = result.plusMonths(1);
        contract9.m_expiry = result.toString(customFormatter);
       
        //create 9 unique ids for each historical data request
        // associate the unique id with each contract
        idsForReqs +=1;
        contractList.put(idsForReqs,contract1);
        idsForReqs +=1;
        contractList.put(idsForReqs,contract2);
        idsForReqs +=1;
        contractList.put(idsForReqs,contract3);
        idsForReqs +=1;
        contractList.put(idsForReqs,contract4);
        idsForReqs +=1;
        contractList.put(idsForReqs,contract5);
        idsForReqs +=1;
        contractList.put(idsForReqs,contract6);
        idsForReqs +=1;
        contractList.put(idsForReqs,contract7);
        idsForReqs +=1;
        contractList.put(idsForReqs,contract8);
        idsForReqs +=1;
        contractList.put(idsForReqs,contract9);
        
        //iterate through the contract List and set the symbol, the security type and the currency
        
        Iterator<Map.Entry<Integer,Contract>> it = contractList.entrySet().iterator(); 
        while(it.hasNext()){
            Map.Entry<Integer,Contract> entry = it.next();
            // test to see if m_symbol is null before adding. Note that if m_symbol is not null, 
            // then this implies that this contract is already in the contract List. I.e. 
            // I have checked, unchecked and rechecked the checkbox. Also, since contractlist 
            // is a combination of all contracts, this makes sure that only the 9 new contracts
            // created in this method are set
            if (entry.getValue().m_symbol == null){
                entry.getValue().m_symbol = symbol;
                entry.getValue().m_secType = "FUT";
                entry.getValue().m_currency = "USD";
            }
            
        }
        
        //set exchange by iterating though contractlist. Again, make sure m_exchange is null before iterating.
        switch(symbol){
            case "ZC": case "ZW": case "ZO": case "ZL":case "ZN": case "ZB":
                it = contractList.entrySet().iterator(); 
                while(it.hasNext()){
                    Map.Entry<Integer,Contract> entry = it.next();
                    if (entry.getValue().m_exchange == null){
                    entry.getValue().m_exchange = "ECBOT";
                    }
                }
                break;
            case "HG": case "GC": case "SI": case "PA": case "PL": case "CL":
                case "HO": case "NG": 
                it = contractList.entrySet().iterator(); 
                while(it.hasNext()){
                    Map.Entry<Integer,Contract> entry = it.next();
                    if (entry.getValue().m_exchange == null){
                    entry.getValue().m_exchange = "NYMEX";
                    }
                }
                break;
            case "ES":  case "LE": case "GF": case "HE":
                it = contractList.entrySet().iterator(); 
                while(it.hasNext()){
                    Map.Entry<Integer,Contract> entry = it.next();
                    if (entry.getValue().m_exchange == null){
                    entry.getValue().m_exchange = "GLOBEX";
                    }
                }
                break;
        }
       
       //request 1 week of data for each of the 9 months
       
       it = contractList.entrySet().iterator(); 
       while(it.hasNext()){
            Map.Entry<Integer,Contract> entry = it.next();
            // make sure the unique key is not already in the keySymbols because we don't want to replace one association
            // with another. I.e. since I'm iterating through the entire contract list, I will get the list from ZC, ZW, etc
            // I have to make sure that I am only requesting for the 9 contracts in this method, these 9 contracts will have
            // keys that don't exist. The remaining list of contracts should have keys that already exist in the list.
            if (!keySymbols.containsKey(entry.getKey())){
                keySymbols.put(entry.getKey(),entry.getValue().m_symbol);
                connection.reqHistoricalData(entry.getKey(), entry.getValue(), dt.toString(formatterForHistoricalData), 
                       "1 W","1 day", "TRADES", 1, 1);
            }
       }

    }
        
    public void getHistoricalDataFields(int reqId, String date, double open, double high, double low,
                      double close, int volume, int count, double WAP, boolean hasGaps){
        
        if (volume!=-1){
            volumes.put(reqId,volume);
            hd_volume = volume;
            hd_open = open;
            hd_high = high;
            hd_low = low;
            hd_close = close;
            hd_barsize = close-open;
            
            if (contractListDownloadedToPSQL.containsKey(reqId) && date.length() ==8){
                DateTime dtnow = new DateTime();
                boolean lessThanOrEqual = true;
                switch(contractListDownloadedToPSQL.get(reqId).m_symbol){
                    case "ZC": case "ZW": case "ZO": case "ZL":
                        if (dtnow.getMinuteOfDay() >=855 && dtnow.getMinuteOfDay() <1200 ){
                            lessThanOrEqual = true;
                        }
                        else {
                            lessThanOrEqual = false;
                        }
                        break;
                    case "ES":
                        if (dtnow.getMinuteOfDay() >=975 && dtnow.getMinuteOfDay() <990 ){
                            lessThanOrEqual = true;
                        }
                        else {
                            lessThanOrEqual = false;
                        }
                        break;
                    case "LE": case "GF": case "HE": case "ZN": case "ZB":
                        if (dtnow.getMinuteOfDay() >=1020 && dtnow.getMinuteOfDay() <1080 ){
                            lessThanOrEqual = true;
                        }
                        else {
                            lessThanOrEqual = false;
                        }
                        break;
                    case "HG": case "GC": case "SI": case "PA": case "PL": case "CL":
                    case "HO": case "NG": 
                        if (dtnow.getMinuteOfDay() >=1035 && dtnow.getMinuteOfDay() <1080 ){
                            lessThanOrEqual = true;
                        }
                        else {
                            lessThanOrEqual = false;
                        }
                        break;
                }
                
                
                if (lessThanOrEqual) {
                    int now = Integer.parseInt(dtnow.toString("yyyyMMdd"));
                    int dateint = Integer.parseInt(date);
                    if (dateint <= now){
                
                        try{

                        con = DriverManager.getConnection(url, "developer", "password");
                        st = con.createStatement();
                        st.executeUpdate("INSERT INTO " + contractListDownloadedToPSQL.get(reqId).m_symbol + contractListDownloadedToPSQL.get(reqId).m_expiry
                                + "( _date, open,high,low, close, volume, barsize) VALUES"
                                + "('" + date +"'," + hd_open +","+ hd_high +"," +hd_low+
                                "," + hd_close + "," + hd_volume + "," + hd_barsize+")");

                        }

                        catch (Exception e){
                            Logger.getLogger(IBTradeGui.class.getName()).log(java.util.logging.Level.SEVERE, null, e);
                        } finally {
                            try {
                                if (st != null) {
                                    st.close();
                                }
                                if (con != null) {
                                    con.close();
                                }

                               } catch (SQLException ex) {
                                Logger.getLogger(IBTradeGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
                                }
                            }
                        }
                 } 
                else {
                    int now = Integer.parseInt(dtnow.toString("yyyyMMdd"));
                    int dateint = Integer.parseInt(date);
                    if (dateint < now){
                
                        try{

                        con = DriverManager.getConnection(url, "developer", "password");
                        st = con.createStatement();
                        st.executeUpdate("INSERT INTO " + contractListDownloadedToPSQL.get(reqId).m_symbol + contractListDownloadedToPSQL.get(reqId).m_expiry
                                + "( _date, open,high,low, close, volume, barsize) VALUES"
                                + "('" + date +"'," + hd_open +","+ hd_high +"," +hd_low+
                                "," + hd_close + "," + hd_volume + "," + hd_barsize+")");

                        }

                        catch (Exception e){
                            Logger.getLogger(IBTradeGui.class.getName()).log(java.util.logging.Level.SEVERE, null, e);
                        } finally {
                            try {
                                if (st != null) {
                                    st.close();
                                }
                                if (con != null) {
                                    con.close();
                                }

                               } catch (SQLException ex) {
                                Logger.getLogger(IBTradeGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
                                }
                            }
                    }
                }   
            }
        }
    }
    
    public static void findMostActiveContracts(){
        
        Iterator<Map.Entry<Integer,Integer>> it2;  
       for (int i = 0; i < tradingSymbols.size();i++){ 
            int largestVolume = 0;
            int largestKey = 0;
            it2 = volumes.entrySet().iterator();  
            while(it2.hasNext()){
                 Map.Entry<Integer,Integer> entry2 = it2.next();
                 if (keySymbols.containsKey(entry2.getKey())){
                     if (keySymbols.get(entry2.getKey()).equals(tradingSymbols.get(i))){
                        if (entry2.getValue()>largestVolume){
                            largestVolume = entry2.getValue();
                            largestKey = entry2.getKey();
                        }
                     }
                 }
            }
            
            mostActiveContractList.put(tradingSymbols.get(i),contractList.get(largestKey));
            
            
            
            
        }
       
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(IBTradeGui.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        
        
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                //initialize scheduler and scheduler factory
                sf = new StdSchedulerFactory();
                try {
                    sched = sf.getScheduler();
                    sched.start(); //start scheduler
                } catch (SchedulerException ex) {
                    Logger.getLogger(IBTradeGui.class.getName()).log(Level.SEVERE, null, ex);
                }
                // open reqsids file to see current id
                try {
                    FileReader fr = new FileReader("idsForRequests.txt");
                    BufferedReader br = new BufferedReader(fr);
                    String str;
                    while ((str=br.readLine()) != null){
                        idsForReqs = Integer.parseInt(str);
                    }
                    
                    br.close();
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(IBTradeGui.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IOException ex) {
                    Logger.getLogger(IBTradeGui.class.getName()).log(Level.SEVERE, null, ex);
                }
                
                //instantiate the GUI
                final IBTradeGui TradeInstance = new IBTradeGui();
                TradeInstance.setVisible(true);
                TradeInstance.textConnectionStatus.setHorizontalAlignment(JTextField.CENTER);
                wrapper.referenceIBTradeGui(TradeInstance);
                TradeInstance.addWindowListener(new java.awt.event.WindowAdapter(){
                    @Override
                    public void windowClosing(java.awt.event.WindowEvent winEvt){
                        try {
                            //save new idsForReqs to file on close
                            FileWriter fw = new FileWriter("idsForRequests.txt");
                            PrintWriter pw = new PrintWriter(fw);
                            pw.println(Integer.toString(idsForReqs));
                            pw.close();
                            sched.shutdown(true); //shut down scheduler on close
                        } catch (IOException | SchedulerException ex) {
                            Logger.getLogger(IBTradeGui.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                });
                // open new separate thread to connect and monitor connection status
                new Thread(new connectionStatus(TradeInstance)).start();
            }
        });
        
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel checkBoxesPanel;
    private javax.swing.JCheckBox checkboxCL;
    private javax.swing.JCheckBox checkboxES;
    private javax.swing.JCheckBox checkboxGC;
    private javax.swing.JCheckBox checkboxGF;
    private javax.swing.JCheckBox checkboxHE;
    private javax.swing.JCheckBox checkboxHG;
    private javax.swing.JCheckBox checkboxHO;
    private javax.swing.JCheckBox checkboxLE;
    private javax.swing.JCheckBox checkboxNG;
    private javax.swing.JCheckBox checkboxPA;
    private javax.swing.JCheckBox checkboxPL;
    private javax.swing.JCheckBox checkboxSI;
    private javax.swing.JCheckBox checkboxSelectAll;
    private javax.swing.JCheckBox checkboxZB;
    private javax.swing.JCheckBox checkboxZC;
    private javax.swing.JCheckBox checkboxZL;
    private javax.swing.JCheckBox checkboxZN;
    private javax.swing.JCheckBox checkboxZO;
    private javax.swing.JCheckBox checkboxZW;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel labelConnectionStatus;
    private javax.swing.JLabel labelSessionProfit;
    private javax.swing.JTextField textConnectionStatus;
    private javax.swing.JTextField textSessionProfit;
    private javax.swing.JTextArea textTradeList;
    private javax.swing.JButton tradeButton;
    // End of variables declaration//GEN-END:variables
}
